import angular from 'angular'
import Bluebird from 'bluebird'
// import filter from 'lodash.filter'
import foreach from 'lodash.foreach'
import keys from 'lodash.keys'
import union from 'lodash.union'

import xo from 'xo'
import xoNotify from 'xo-notify'

// ===================================================================

// TODO: remove when no longer used.
export default angular.module('xoWebApp.services', [
  xo,
  xoNotify
])
  // Alias the service for compatibility.
  .service('notify', (xoNotify) => xoNotify)
  .service('xoAggregate', function (xo, notify, bytesToSizeFilter) {
    function refreshStats (objects, level) {
      let statPromises
      statPromises = []
      foreach(objects, function (object) {
        const apiType = (object.type === 'host' && 'host') || (object.type === 'VM' && 'vm') || undefined
        if (!apiType) {
          notify.error({
            title: 'Unhandled object ' + (objects.name_label || ''),
            message: 'There is no stats available for this type of objects'
          })
          object._ignored = true
        } else {
          delete object._ignored
          statPromises.push(
            xo[apiType].refreshStats(object.id, level) // 2: week granularity (7 * 24 hours)
            .then(rawStats => ({object, rawStats}))
            .catch(error => {
              error.object = object
              object._ignored = true
              throw error
            })
          )
        }
      })
      console.log('Promises length ', statPromises.length)
      return Bluebird
        .settle(statPromises)
        .then(function (stats) {
          let agglomeratedStats, statKeys
          statKeys = []
          agglomeratedStats = {
            details: {}
          }
          foreach(stats, function (statePromiseInspection) { // One object...
            if (statePromiseInspection.isRejected()) {
              notify.warning({
                title: 'Error fetching stats',
                message: 'Metrics do not include ' + statePromiseInspection.reason().object.name_label
              })
              return true // continue to next promise
            }
            if (!statePromiseInspection.isFulfilled()) {
              // neither rejected or accepted WTF ?
              notify.warning({
                title: 'Error fetching stats',
                message: 'Promises neither fulfilled or rejected'
              })
              return true
            }

            const {object, rawStats} = statePromiseInspection.value()
            const nb = rawStats.date.length
            let metrics, metricName
            metrics = {}
            foreach(rawStats, function (stat, statKey) {
              let statCounter, dateCounter, sum
              if (statKey === 'date') {
                return true
              }
              if (stat[0] instanceof Array) {
                // init arrays
                if (statKey === 'cpus') {
                  metrics['All CPUs'] = []
                }
                for (statCounter = 0; statCounter < stat.length; statCounter++) {
                  metricName = computeMetricFullname(statKey, statCounter)
                  if (statKey !== 'cpus') { // hosts can have 32+ cpu, don't want the detail
                    metrics[metricName] = []
                  }
                }
                for (dateCounter = 0; dateCounter < nb; dateCounter++) {
                  const d = new Date(rawStats.date[dateCounter] * 1000)
                  sum = 0
                  for (statCounter = 0; statCounter < stat.length; statCounter++) {
                    const v = computeValue(stat[statCounter][dateCounter])
                    metricName = computeMetricFullname(statKey, statCounter)
                    sum += v
                    if (statKey !== 'cpus') { // hosts can have 32+ cpu, don't want the detail
                      metrics[metricName].push({
                        date: d,
                        value: v,
                        textValue: computeTextValue(object, statKey, v)
                      })
                    }
                  }

                  if (statKey === 'cpus') {
                    metrics['All CPUs'].push({
                      date: d,
                      value: sum / stat.length,
                      textValue: computeTextValue(object, statKey, sum / stat.length)
                    })
                  }
                }
              } else {
                metricName = computeMetricFullname(statKey, '')
                metrics[metricName] = []
                for (dateCounter = 0; dateCounter < nb; dateCounter++) {
                  const d = new Date(rawStats.date[dateCounter] * 1000)
                  const v = computeValue(stat[dateCounter])
                  const tv = computeTextValue(object, statKey, v)

                  metrics[metricName].push({
                    date: d,
                    value: v,
                    textValue: tv
                  })
                }
              }
            })
            statKeys = union(statKeys, keys(metrics))
            agglomeratedStats.details[object.id] = metrics
          })
          // agglomerate objects stats
          agglomeratedStats.keys = statKeys.sort()
          /*
          foreach(statKeys, function (statKey) {
            let dateCounter, sum, d
            const objectWithstats = filter(agglomeratedStats.details, statKey)
            const nb = objectWithstats[0][statKey].length // I assume they're all the same length
            agglomeratedStats[statKey + '_sum'] = []
            agglomeratedStats[statKey + '_average'] = []
            for (dateCounter = 0; dateCounter < nb; dateCounter++) {
              sum = 0
              foreach(objectWithstats, function (objectWithStat) {
                sum += objectWithStat[statKey][dateCounter].value
                d = objectWithStat[statKey][dateCounter].date
              })
              agglomeratedStats[statKey + '_average'].push({
                date: d,
                value: sum / objectWithstats.length
              })
              agglomeratedStats[statKey + '_sum'].push({
                date: d,
                value: sum
              })
            }
          })*/
          console.log(agglomeratedStats)
          return agglomeratedStats
        })
      function computeValue (value) {
        const v = parseFloat(value, 10)
        if (isNaN(v)) {
          return 0
        }
        return v
      }
      function computeTextValue (object, statKey, value) {
        switch (statKey) {
          case 'vifs':
          case 'pifs':
          case 'xvds':
            return bytesToSizeFilter(value)
          case 'memoryUsed':
          case 'memory':
          case 'memoryFree':
            return bytesToSizeFilter(object.type === 'host' ? value * 1024 : value)
          default :
            return Math.round(value * 100) / 100
        }
      }
      function computeMetricFullname (statKey, index) {
        let metricName
        switch (statKey) {
          case 'vifs':
            metricName = 'Network ' + Math.floor(index / 2) + ' ' + (index % 2 ? 'out' : 'in')
            break
          case 'pifs' :
            metricName = 'NIC ' + Math.floor(index / 2) + ' ' + (index % 2 ? 'out' : 'in')
            break
          case 'xvds' :
            metricName = 'Disk ' + String.fromCharCode(Math.floor(index / 2) + 65) + ' ' + (index % 2 ? 'write' : 'read')
            break
          case 'memoryUsed' :
            metricName = 'RAM (Used)'
            break
          case 'memory' :
            metricName = 'RAM (Total)'
            break
          case 'memoryFree' :
            metricName = 'RAM (Unused)'
            break
          case 'load' :
            metricName = 'Load average'
            break
          default :
            metricName = statKey + index
        }
        return metricName
      }
    }

    return {
      refreshStats
    }
  })
  .name
