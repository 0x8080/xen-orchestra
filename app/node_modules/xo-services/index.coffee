angular = require 'angular'

#=====================================================================

# TODO: split into multiple modules.
module.exports = angular.module 'xoWebApp.services', [
  require 'angular-animate'
  require 'angular-cookies'

  require 'angular-notify-toaster'

  require 'xo-api'
]

  .service 'notify', (toaster) ->
    notifier = (level) ->
      (options) ->
        if angular.isString options
          options = { message: options }
        else
          throw new Error 'missing message' unless options.message

        toaster.pop(
          level
          options.title ? 'Xen-Orchestra'
          options.message
        )

    {
      warning: notifier 'warning'
      error: notifier 'error'
      info: notifier 'info'
      # TODO: It is probably a bad design to have notification for
      # successful operations.
      # success: notifier 'success'
    }

  .service 'xo', (xoApi, notify) ->
    action = (name, method, options) ->
      unless method
        return ->
          notify.info {
            title: name
            message: 'This feature has not been implemented yet.'
          }

          # TODO: A (broken) promise should be returned for
          # consistency.

      {argsMapper, notification} = options ? {}

      # FIXME: default mapper should be identity.
      argsMapper ?= (id) -> {id}

      (args...) ->
        xoApi.call(
          method
          argsMapper args...
        ).catch (error) ->
          unless notification is false
            code = error?.code
            message = if code is 2
              'You don\'t have the permission.'
            else
              'The action failed for unknown reason.'

            notify.warning {
              title: name
              message
            }

          console.error error

          # Re-throws the error to make it available in the promise
          # chain.
          throw error

    # The interface.
    xo = {
      # objects: xoApi.all
      byTypes: xoApi.byTypes
      # revision: xoObjects.revision # Implemented below as a getter.

      get: xoApi.get

      pool:
        disconnect: action 'Disconnect pool'
        new_sr: action 'New SR' #temp fix before creating SR
        patch: action 'Upload patch', 'pool.patch', argsMapper: (pool) -> {pool}

      host:
        attach:           action 'Atach host'#, 'host.attach'
        detach:           action 'Detach host', 'host.detach'
        restart:          action 'Restart host', 'host.restart'
        restartToolStack: action 'Restart tool stack', 'host.restart_agent'
        start:            action 'Start host', 'host.start'
        enable:           action 'Enable host', 'host.enable'
        stop:             action 'Stop host', 'host.stop'
        disable:          action 'Disable host', 'host.disable'
        new_sr:           action 'New SR' #temp fix before creating SR
        # TODO: attach/set

      log:
        delete: action 'Delete Log', 'message.delete'

      message:
        delete: action 'Delete message'

      pbd:
        delete: action 'Delete PBD'
        disconnect: action 'Disconnect PBD'

      server:
        add: action 'Add server', 'server.add', argsMapper: (params) -> params
        remove: action 'Remove server', 'server.remove', argsMapper: (id) -> {id}
        getAll: action 'Getting server', 'server.getAll'
        set: action 'Save server', 'server.set', argsMapper: (params) -> params

      task:
        cancel: action 'Cancel task', 'task.cancel', argsMapper: (id) -> {id}

      user:
        create: action 'Create user', 'user.create', argsMapper: (params) -> params
        delete: action 'Delete user', 'user.delete', argsMapper: (id) -> {id}
        getAll: action 'Getting user', 'user.getAll'
        set: action 'Save user', 'user.set', argsMapper: (params) -> params

      vm:
        convert: action 'Convert VM', 'vm.convert', {
          argsMapper: (id) -> {id}
        }
        clone: action 'Copy VM', 'vm.clone', {
          argsMapper: (id, name, full_copy) -> {id, name, full_copy} #todo : sr ref to choose target SR
        }
        createSnapshot: action 'Create VM snapshot', 'vm.snapshot', {
          argsMapper: (id, name) -> {id, name}
        }
        export: action 'Export VM', 'vm.export', {
          argsMapper: (vm, compress = true) -> {vm, compress}
        }
        delete: action 'Delete VM', 'vm.delete', {
          argsMapper: (id, delete_disks) -> { id, delete_disks }
        }
        ejectCd: action 'Eject disc', 'vm.ejectCd'
        insertCd: action 'Insert disc', 'vm.insertCd', {
          argsMapper: (id, cd_id, force = false) -> { id, cd_id, force }
        }
        import: action 'Import VM', 'vm.import', {
          argsMapper: (host) -> { host }
        }
        migrate: action 'Migrate VM', 'vm.migrate', {
          argsMapper: (id, host_id) -> { id, host_id }
        }
        migratePool: action 'Migrate VM to another pool', 'vm.migrate_pool', {
          argsMapper: (params) -> params
        }
        restart: action 'Restart VM', 'vm.restart', {
          argsMapper: (id, force = false) -> { id, force }
        }
        start: action 'Start VM', 'vm.start'
        stop: action 'Stop VM', 'vm.stop', {
          argsMapper: (id, force = false) -> { id, force }
        }
        revert: action 'Revert snapshot', 'vm.revert'
        suspend: action 'Suspend VM', 'vm.suspend'
        resume: action 'Resume VM', 'vm.resume', {
          argsMapper: (id, force = true) -> { id, force }
        }
        # TODO: create/set/pause

      vdi:
        delete: action 'Delete VDI', 'vdi.delete'
        migrate: action 'Migrate VDI', 'vdi.migrate', {
          argsMapper: (id, sr_id) -> { id, sr_id }
        }

      vif:
        delete: action 'Delete VIF', 'vif.delete'
        disconnect: action 'Disconnect VIF', 'vif.disconnect'
        connect: action 'Connect VIF', 'vif.connect'

      vbd:
        delete: action 'Delete VBD', 'vbd.delete'
        disconnect: action 'Disconnect VBD', 'vbd.disconnect'
        connect: action 'Connect VBD', 'vbd.connect'
    }

    # Adds the dynamic properties.
    Object.defineProperties(xo, {
      all: { get: -> xoApi.all },
      byTypes: { get: -> xoApi.byTypes },
      revision: { get: -> xoApi.revision },
    })

    # Returns the interface.
    xo

  # A module exports its name.
  .name
