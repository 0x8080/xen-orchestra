'use strict'

import angular from 'angular'
import cubism from 'cubism'
import d3 from 'd3'

import clone from 'lodash.cloneDeep'
import find from 'lodash.find'
import filter from 'lodash.filter'
import foreach from 'lodash.foreach'

const $ = window.$

export default angular.module('xoCubism', [])
  .directive('cubism', function ($parse, $timeout) {
    function link (scope, element, attrs) {
      $timeout(function () {
        init()  // D3 need a dom width and height
      }, 0)
      function init () {
        let $e, metrics, sources
        metrics = []
        sources = {}
        $e = $(element[0])
        while ($e.width() === 0 && $e.parent()) {
          $e = $e.parent()
        }
        const size = $e.width()
        const step = scope.step || 5000
        const context = cubism.context()
           .serverDelay(60 * 1000)
           .clientDelay(60 * 1000)
          .step(step)
          .size(size)

        scope.$watch(() => scope.chartData, function (newvalue) {
          let hasone = false
          foreach(newvalue, function (data, key) {
            let metric
            hasone = true
            metric = find(metrics, {title: key})
            /*

            */
            sources[key] = clone(data)
            if (!metric) {
              metric = context.metric(
                function (start, stop, step, callback) {
                  let values, item, date
                  values = []
                  date = +start
                  stop = +stop
                  while (date < stop) {
                    item = find(sources[key], {date: new Date(date)})
                    if (item) {
                      values.push(item.value)
                    } else {
                      values.push(null)
                    }
                    date += step
                  }

                  callback(null, values)

                  // time only go forward, purge old values
                  sources[key] = filter(sources[key], function (datum) {
                    return datum.date >= start
                  })
                })
              metric.title = key
              metrics.push(metric)
            }
          })

          if (!hasone) {
            return
          }
          const container = d3.select(element[0])

          if (container.select('.axis').empty()) {
            container
              .append('div')
              .attr('class', 'axis')
              .call(context.axis().orient('top'))
          }

          container
            .selectAll('.horizon')
            .data(metrics)
            .enter().append('div')
            .attr('class', 'horizon')
            .call(
              context
              .horizon()
              .height(120)
              .title(function (metric) {
                return metric.title + ' '
              })
              .extent(function (metric) {
                if (scope.extents) {
                  return scope.extents[metric.title]
                }
                return null
              })
              .format(function (value) {
                return value
              })
            )

          if (container.select('.rule').empty()) {
            container.append('div')
              .attr('class', 'rule')
              .call(context.rule())
          }
        }, true)
      }
    }

    return {
      resctict: 'E',
      replace: false,
      scope: {
        step: '=',
        size: '=',
        chartData: '=',
        extents: '=',
        over: '&',
        click: '&'
      },
      link: link
    }
  })
  // A module exports its name.
  .name
