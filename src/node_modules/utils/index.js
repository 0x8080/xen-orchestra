import filter from 'lodash/filter'
import isArray from 'lodash/isArray'
import isFunction from 'lodash/isFunction'
import mapValues from 'lodash/mapValues'
import pick from 'lodash/fp/pick'
import { connect } from 'react-redux'
import { createSelector } from 'reselect'

import * as actions from '../../store/actions'

// ===================================================================

const _normalizeMapStateToProps = (mapper) => {
  if (isFunction(mapper)) {
    return mapper
  }

  if (isArray(mapper)) {
    return pick(mapper)
  }

  mapper = mapValues(mapper, _normalizeMapStateToProps)
  return (state, props) => mapValues(mapper, (fn) => fn(state, props))
}

export const connectStore = (mapStateToProps) => connect(
  _normalizeMapStateToProps(mapStateToProps),
  actions
)

// -------------------------------------------------------------------

export const createFilter = (
  collectionSelector,
  filterSelector,
  valueGetter
) => createSelector(
  collectionSelector,
  filterSelector,
  (collection, filter_) => {
    if (!filter_) {
      return collection
    }

    filter_ = String(filter_).toLowerCase()
    return filter(
      collection,
      (item) => String(valueGetter(item)).toLowerCase().indexOf(filter_) !== -1
    )
  }
)

// -------------------------------------------------------------------

// Invoke a function and returns it result.
// All parameters are forwarded.
//
// Why using `invoke()`?
// - avoid tedious IIFE syntax
// - avoid declaring variables in the common scope
//
// ```js
// const sum = invoke(1, 2, (a, b) => a + b)
// ```
export function invoke () {
  const n = arguments.length - 1
  const fn = arguments[n]
  const args = new Array(n)
  for (let i = 0; i < n; ++i) {
    args[i] = arguments[i]
  }

  return fn.apply(undefined, args)
}
