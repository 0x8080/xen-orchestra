import assign from 'lodash/assign'
import filter from 'lodash/filter'
import forEach from 'lodash/forEach'
import humanFormat from 'human-format'
import isArray from 'lodash/isArray'
import isFunction from 'lodash/isFunction'
import mapValues from 'lodash/mapValues'
import pick from 'lodash/fp/pick'
import { connect } from 'react-redux'
import { createSelector } from 'reselect'
import { PropTypes } from 'react'

import * as actions from '../../store/actions'

// ===================================================================

const _normalizeMapStateToProps = (mapper) => {
  if (isFunction(mapper)) {
    return mapper
  }

  if (isArray(mapper)) {
    return pick(mapper)
  }

  mapper = mapValues(mapper, _normalizeMapStateToProps)
  return (state, props) => mapValues(mapper, (fn) => fn(state, props))
}

export const connectStore = (mapStateToProps) => connect(
  _normalizeMapStateToProps(mapStateToProps),
  actions
)

// -------------------------------------------------------------------

export const createFilter = (
  collectionSelector,
  filterSelector,
  valueGetter
) => createSelector(
  collectionSelector,
  filterSelector,
  (collection, filter_) => {
    if (!filter_) {
      return collection
    }

    filter_ = String(filter_).toLowerCase()
    return filter(
      collection,
      (item) => String(valueGetter(item)).toLowerCase().indexOf(filter_) !== -1
    )
  }
)

// -------------------------------------------------------------------

const osToFamily = (function (osByFamily) {
  const osToFamily = Object.create(null)

  forEach(osByFamily, (list, family) => {
    forEach(list, (os) => {
      osToFamily[os] = family
    })
  })

  return osToFamily
})({
  linux: [
    'coreos'
  ],
  centos: [
    'centos'
  ],
  debian: [
    'debian'
  ],
  fedora: [
    'fedora'
  ],
  gentoo: [
    'gentoo'
  ],
  oracle: [
    'oracle'
  ],
  redhat: [
    'redhat',
    'rhel'
  ],
  ubuntu: [
    'ubuntu'
  ],
  solaris: [
    'solaris'
  ],
  freebsd: [
    'freebsd'
  ],
  netbsd: [
    'netbsd'
  ],
  osx: [
    'osx'
  ],
  'linux-mint': [
    'linux-mint'
  ],
  suse: [
    'sles',
    'suse'
  ],
  windows: [
    'windows'
  ]
})

export const osFamily = (osName) => osToFamily[osName.toLowerCase()] || 'other'

// -------------------------------------------------------------------

// Invoke a function and returns it result.
// All parameters are forwarded.
//
// Why using `invoke()`?
// - avoid tedious IIFE syntax
// - avoid declaring variables in the common scope
// - monkey-patching
//
// ```js
// const sum = invoke(1, 2, (a, b) => a + b)
//
// eventEmitter.emit = invoke(eventEmitter.emit, (emit) => function (event) {
//   if (event === 'foo') {
//     throw new Error('event foo is disabled')
//   }
//
//   return emit.apply(this, arguments)
// })
// ```
export function invoke () {
  const n = arguments.length - 1
  const fn = arguments[n]
  const args = new Array(n)
  for (let i = 0; i < n; ++i) {
    args[i] = arguments[i]
  }

  return fn.apply(undefined, args)
}

// -------------------------------------------------------------------

export const propTypes = (types) => (target) => {
  target.propTypes = types

  return target
}
assign(propTypes, PropTypes)

// -------------------------------------------------------------------

export const formatSize = (bytes) => humanFormat(bytes, { scale: 'binary', unit: 'B' })

export const parseSize = (size) => {
  let bytes = humanFormat.parse.raw(size, { scale: 'binary' })
  if (bytes.unit && bytes.unit !== 'B') {
    bytes = humanFormat.parse.raw(size)

    if (bytes.unit && bytes.unit !== 'B') {
      throw new Error('invalid size: ' + size)
    }
  }
  return Math.floor(bytes.value * bytes.factor)
}
