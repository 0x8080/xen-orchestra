import assign from 'lodash/assign'
import filter from 'lodash/filter'
import forEach from 'lodash/forEach'
import humanFormat from 'human-format'
import isArray from 'lodash/isArray'
import every from 'lodash/every'
import isFunction from 'lodash/isFunction'
import mapValues from 'lodash/mapValues'
import pick from 'lodash/fp/pick'
import React, { PropTypes } from 'react'
import { connect } from 'react-redux'
import { createSelector } from 'reselect'

import * as actions from '../../store/actions'

// ===================================================================

const _normalizeMapStateToProps = (mapper) => {
  if (isFunction(mapper)) {
    return mapper
  }

  if (isArray(mapper)) {
    return pick(mapper)
  }

  mapper = mapValues(mapper, _normalizeMapStateToProps)
  return (state, props) => mapValues(mapper, (fn) => fn(state, props))
}

export const connectStore = (mapStateToProps) => connect(
  _normalizeMapStateToProps(mapStateToProps),
  actions
)

// -------------------------------------------------------------------

// Wraps a function which returns a collection to returns the previous
// result if the collection has not really changed (ie still has the
// same items).
//
// Use case: in connect, to avoid rerendering a component where the
// objects are still the same.
export const createCollectionSelector = invoke(
  (c1, c2) => {
    if (c1 === c2) {
      return true
    }

    const type = typeof c1
    if (type !== typeof c2) {
      return false
    }

    if (type === 'array') {
      if (c1.length !== c2.length) {
        return false
      }
    }

    return every(c1, (value, key) => c2[key] === value)
  },
  (areCollectionsEqual) => (selector) => {
    let cache

    return (...args) => {
      const value = selector(...args)
      if (!areCollectionsEqual(value, cache)) {
        cache = value
      }
      return cache
    }
  }
)

// -------------------------------------------------------------------

export const createFilter = (
  collectionSelector,
  filterSelector,
  valueGetter
) => createSelector(
  collectionSelector,
  filterSelector,
  (collection, filter_) => {
    if (!filter_) {
      return collection
    }

    filter_ = String(filter_).toLowerCase()
    return filter(
      collection,
      (item) => String(valueGetter(item)).toLowerCase().indexOf(filter_) !== -1
    )
  }
)

// -------------------------------------------------------------------

export const osFamily = invoke({
  linux: [
    'coreos'
  ],
  centos: [
    'centos'
  ],
  debian: [
    'debian'
  ],
  fedora: [
    'fedora'
  ],
  gentoo: [
    'gentoo'
  ],
  oracle: [
    'oracle'
  ],
  redhat: [
    'redhat',
    'rhel'
  ],
  ubuntu: [
    'ubuntu'
  ],
  solaris: [
    'solaris'
  ],
  freebsd: [
    'freebsd'
  ],
  netbsd: [
    'netbsd'
  ],
  osx: [
    'osx'
  ],
  'linux-mint': [
    'linux-mint'
  ],
  suse: [
    'sles',
    'suse'
  ],
  windows: [
    'windows'
  ]
}, (osByFamily) => {
  const osToFamily = Object.create(null)
  forEach(osByFamily, (list, family) => {
    forEach(list, (os) => {
      osToFamily[os] = family
    })
  })

  return (osName) => osToFamily[osName.toLowerCase()] || 'other'
})

// -------------------------------------------------------------------

// Invoke a function and returns it result.
// All parameters are forwarded.
//
// Why using `invoke()`?
// - avoid tedious IIFE syntax
// - avoid declaring variables in the common scope
// - monkey-patching
//
// ```js
// const sum = invoke(1, 2, (a, b) => a + b)
//
// eventEmitter.emit = invoke(eventEmitter.emit, (emit) => function (event) {
//   if (event === 'foo') {
//     throw new Error('event foo is disabled')
//   }
//
//   return emit.apply(this, arguments)
// })
// ```
export function invoke () {
  const n = arguments.length - 1
  const fn = arguments[n]
  const args = new Array(n)
  for (let i = 0; i < n; ++i) {
    args[i] = arguments[i]
  }

  return fn.apply(undefined, args)
}

// -------------------------------------------------------------------

export const propTypes = (types) => (target) => {
  target.propTypes = types

  return target
}
assign(propTypes, PropTypes)

// -------------------------------------------------------------------

export const formatSize = (bytes) => humanFormat(bytes, { scale: 'binary', unit: 'B' })

export const parseSize = (size) => {
  let bytes = humanFormat.parse.raw(size, { scale: 'binary' })
  if (bytes.unit && bytes.unit !== 'B') {
    bytes = humanFormat.parse.raw(size)

    if (bytes.unit && bytes.unit !== 'B') {
      throw new Error('invalid size: ' + size)
    }
  }
  return Math.floor(bytes.value * bytes.factor)
}

// -------------------------------------------------------------------

export const normalizeXenToolsStatus = (status) => {
  if (status === false) {
    return 'not-installed'
  }
  if (status === undefined) {
    return 'unknown'
  }
  if (status === 'up to date') {
    return 'up-to-date'
  }
  return 'out-of-date'
}

// -------------------------------------------------------------------

export const Debug = ({ value }) => <pre>
  {JSON.stringify(value, null, 2)}
</pre>
